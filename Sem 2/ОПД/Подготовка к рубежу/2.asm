; Задание: Подсчет суммы элементов массива, которые делятся на 17, числа хранятся в 32 разрядной сетке

ORG             0x0010
WORD            0x0011      ; 1-й элемент младшее слово
WORD            0x0000      ; 1-й элемент старшее слово
WORD            0x0000      ; 2-й элемент младшее слово
WORD            0x0022      ; 2-й элемент старшее слово
WORD            0x0004      ; И так далее...
WORD            0x0033
WORD            0x0000
WORD            0x0000
WORD            0x0044
WORD            0x0011
WORD            0x0011
WORD            0x0000
WORD            0x0000
WORD            0x0022
WORD            0x0004
WORD            0x0033
WORD            0x0000
WORD            0x0000
WORD            0x0044
WORD            0x0011

ORG             0x0050      ; Адрес начала программы
ARRAY: WORD     0x0010      ; Адрес начала массива
CURRENT_1: WORD 0x0000      ; Текущий элемент массива, младшее слово
CURRENT_2: WORD 0x0000      ; Текущий элемент массива, старшее слово
DIVIDER: WORD   0x0011      ; Делитель 17
COUNTER: WORD   0x000A      ; Счетчик цикла
RESULT_1: WORD  0x0000      ; Результат, младшее слово
RESULT_2: WORD  0x0000      ; Результат, старшее слово

START:                      ; Начало программы
            LD COUNTER      ; Загрузка счетчика
            DEC             ; Декремент счетчика
            ST COUNTER      ; Сохранение счетчика
            BMI EXIT        ; Выход из цикла, если счетчик < 0
            LD (ARRAY)+     ; Получаем младшее слово элемента массива
            ST CURRENT_1    ; Сохранение младшего слова элемента массива
            LD (ARRAY)+     ; Получаем старшее слово элемента массива
            ST CURRENT_2    ; Сохранение старшего слова элемента массива
            BMI NEG_32      ; Если число < 0, меняем знак

DIVISION:                   ; Цикл деления
            CALL SUB_DEV_32 ; Вызов функции вычитания делителя
            LD CURRENT_2    ; Загрузка старшего слова текущего чесла
            BMI START       ; Если число < 0, пропускаем итерацию
            ADD CURRENT_1   ; Прибавляем младшее слово
            BEQ ADD_TO_RES  ; Если сумма слов будет = 0, то прибавляем к результату
            JUMP DIVISION   ; Зацикливаем вычитание

SUB_DEV_32:                 ; Вычитание реализовано через двойную смену знака и сложение -(-A+B)
            CALL NEG_32     ; Вызов функции смены знака
            LD CURRENT_1    ; Загрузка младшего слова
            ADD DIVIDER     ; Прибавляем делитель к младшему слову
            ST CURRENT_1    ; Сохранение младшее слово
            CLA             ; Очистка аккумулятора
            ADC CURRENT_2   ; Прибавляем флаг переноса к старшему слову
            ST CURRENT_2    ; Сохранение старшего слова
            CALL NEG_32     ; Вызов функции смены знака
            RET             ; Выход из подпрограммы

NEG_32:                     ; Смена знака числа CURRENT
            LD CURRENT_2    ; Загрузка старшее слово
            NOT             ; Вычитание дополнения
            ST CURRENT_2    ; Сохранение старшего слова
            LD CURRENT_1    ; Загрузка младшего слово
            NEG             ; Вычисление доп.кода
            ST CURRENT_1    ; Сохранение младшего слова
            CLA             ; Очистка аккумулятора
            ADC CURRENT_2   ; Добавление возможного переноса к старшему слову
            ST CURRENT_2    ; Сохранение старшего слова
            RET             ; Выход из подпрограммы


ADD_TO_RES:                 ; Сохранение результата RESULT+=CURRENT
            LD RESULT_1     ; Загрузка мдадшего слова результата
            ADD CURRENT_1   ; Сумма с младшим словом CURRENT
            ST RESULT_1     ; Сохранение младшего слова результата
            LD RESULT_2     ; Загрузка старшего слова результата
            ADC CURRENT_2   ; Сумма с старсшим словом CURRENT + перенос
            ST RESULT_2     ; Сохранение старшего слова результата
            JUMP START      ; Прыжок на начало программы

EXIT:                       ; Выход из программы
            HLT             ; Останов